warning: in the working copy of 'network/synchronizer/synchronizer.go', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'server/server.go', LF will be replaced by CRLF the next time Git touches it
[1mdiff --git a/network/synchronizer/synchronizer.go b/network/synchronizer/synchronizer.go[m
[1mindex 8ca94a3..21d81d2 100644[m
[1m--- a/network/synchronizer/synchronizer.go[m
[1m+++ b/network/synchronizer/synchronizer.go[m
[36m@@ -59,6 +59,7 @@[m [mtype PeerState struct {[m
 	Height    uint64[m
 	State     SyncState[m
 	BlockHash types.Hash[m
[32m+[m	[32mFirstSeen int64[m
 }[m
 [m
 type InternalSyncMessage struct {[m
[36m@@ -292,6 +293,7 @@[m [mfunc (s *ChainSynchroizer) handleResponseStatusMessage(from types.Address, m *Re[m
 			Height:    m.Height,[m
 			State:     SyncState(m.State),[m
 			BlockHash: m.CurrentBlockHash,[m
[32m+[m			[32mFirstSeen: time.Now().UnixNano(),[m
 		}[m
 		s.availablePeers.Put(from, nps)[m
 		_ = s.logger.Log("msg", "updated sync peer", "peer_address", nps.Address.ShortString(8), "peer_height", m.Height)[m
[36m@@ -445,7 +447,7 @@[m [mfunc (s *ChainSynchroizer) synchronize() {[m
 		return[m
 	}[m
 [m
[31m-	s.removeBehindPeers()[m
[32m+[m	[32ms.pruneStalePeers()[m
 [m
 	bestPeer := s.findBestPeer()[m
 [m
[36m@@ -474,8 +476,10 @@[m [mfunc (s *ChainSynchroizer) synchronize() {[m
 		_ = s.logger.Log("msg", "changed state", "state", s.state.Get())[m
 		return[m
 	} else {[m
[31m-		s.state.Set(Synchronized)[m
[31m-		_ = s.logger.Log("msg", "changed state", "state", s.state.Get())[m
[32m+[m		[32mif !s.state.Eq(Synchronized) {[m
[32m+[m			[32ms.state.Set(Synchronized)[m
[32m+[m			[32m_ = s.logger.Log("msg", "changed state", "state", s.state.Get())[m
[32m+[m		[32m}[m
 	}[m
 [m
 	_ = s.logger.Log("state", s.state.Get(), "available_peers", s.availablePeers.Len())[m
[36m@@ -507,20 +511,19 @@[m [mfunc (s *ChainSynchroizer) findBestPeer() *PeerState {[m
 	return bestPeers[randomIndex][m
 }[m
 [m
[31m-func (s *ChainSynchroizer) removeBehindPeers() {[m
[31m-	currentHeight := s.chain.GetCurrentHeight()[m
[31m-	thresholdHeight := uint64(float64(currentHeight) * 0.8) // 20%[m
[32m+[m[32mfunc (s *ChainSynchroizer) pruneStalePeers() {[m
[32m+[m	[32mthresholdTime := time.Now().Add(-1 * time.Minute).UnixNano()[m
[32m+[m	[32mstalePeers := make([]types.Address, 0)[m
 [m
[31m-	behindPeers := make([]*PeerState, 0)[m
 	s.availablePeers.Range(func(addr types.Address, state *PeerState) bool {[m
[31m-		if state.Height < thresholdHeight {[m
[31m-			behindPeers = append(behindPeers, state)[m
[32m+[m		[32mif state.FirstSeen <= thresholdTime {[m
[32m+[m			[32mstalePeers = append(stalePeers, addr)[m
 		}[m
 		return true[m
 	})[m
 [m
[31m-	for _, peer := range behindPeers {[m
[31m-		s.availablePeers.Remove(peer.Address)[m
[32m+[m	[32mfor _, addr := range stalePeers {[m
[32m+[m		[32ms.availablePeers.Remove(addr)[m
 	}[m
 }[m
 [m
[1mdiff --git a/server/server.go b/server/server.go[m
[1mindex f759f36..a08b18b 100644[m
[1m--- a/server/server.go[m
[1m+++ b/server/server.go[m
[36m@@ -251,7 +251,7 @@[m [mfunc (s *Server) logLoop() {[m
 			peerStr := fmt.Sprintf("[%s]", strings.Join(peersAddrStr, ", "))[m
 			connStr := fmt.Sprintf("(%d/%d)", len(peers), s.MaxPeers)[m
 [m
[31m-			_ = s.Logger.Log("height", s.Chain.GetCurrentHeight(), "state", s.state.Get(), "conn", connStr, "peer", peerStr)[m
[32m+[m			[32m_ = s.Logger.Log("state", s.state.Get(), "height", s.Chain.GetCurrentHeight(), "pending", s.VirtualMemoryPool.Count(), "conn", connStr, "peer", peerStr)[m
 		}[m
 	}[m
 }[m
[36m@@ -459,6 +459,10 @@[m [mfunc (s *Server) processConsensusMessage(rm message.RawMessage) {[m
 		return[m
 	}[m
 [m
[32m+[m	[32mif !s.Synchronizer.IsSynchronized() {[m
[32m+[m		[32mreturn[m
[32m+[m	[32m}[m
[32m+[m
 	cm, err := s.ConsensusMessageCodec.Decode(rm.Payload())[m
 	if err != nil {[m
 		return[m
[36m@@ -646,6 +650,10 @@[m [mfunc (s *Server) startConsensusIfProposal(cm consensus.ConsensusMessage) {[m
 		return[m
 	}[m
 [m
[32m+[m	[32mif !s.Synchronizer.IsSynchronized() {[m
[32m+[m		[32mreturn[m
[32m+[m	[32m}[m
[32m+[m
 	b, isProposal := cm.ProposalBlock()[m
 	if !isProposal {[m
 		return[m
